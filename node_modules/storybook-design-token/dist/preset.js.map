{"version":3,"sources":["../src/plugin.ts","../src/types/token.types.ts","../src/parsers/image.parser.ts","../src/parsers/postcss.parser.ts","../src/parsers/svg-icon.parser.ts","../src/preset.ts"],"names":["existsSync","mkdirSync","readFileSync","writeFileSync","glob","path","TokenPresenter","extname","basename","relative","parsePngFiles","files","tokens","determineTokens","token","v","i","name","file","toBase64","filePath","bitmap","postcss","scss","parseCssFiles","sourceType","injectVariables","relevantFiles","index","f","nodes","getNodes","categories","determineCategories","injectionStyles","k","declaration","comments","declarations","categoryComments","comment","nextComment","nextCommentIsInAnotherFile","nameResults","presenter","range","source","determineTokensForCategory","isCategory","description","value","determineTokenValue","presenterToken","presenterResultsToken","t","rawValue","regex","match","replacedString","variableMatch","variableName","replacement","keyframes","plugin","root","atRule","variableAtRule","syntax","object","JSDOM","parseSvgFiles","document","div","svgs","svg","array","getTokenFilePaths","context","designTokenGlob","pattern","addFilesToWebpackDeps","compilation","generateTokenFilesJsonString","tokenFiles","isImageExtension","cssTokens","scssTokens","lessTokens","svgTokens","imageTokens","StorybookDesignTokenPlugin","compiler","compilationAssets","callback","sourceString","viteStorybookDesignTokenPlugin","options","publicDir","rootDir","resolvedConfig","filename","managerEntries","entry","__require","viteFinal","viteConfig","webpackFinal","config","presets"],"mappings":"6PAAA,OAAS,cAAAA,EAAY,aAAAC,EAAW,gBAAAC,EAAc,iBAAAC,MAAqB,KACnE,OAAOC,MAAU,OACjB,OAAOC,MAAU,OCUV,IAAKC,OACVA,EAAA,UAAY,YACZA,EAAA,OAAS,SACTA,EAAA,cAAgB,eAChBA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,YAAc,aACdA,EAAA,UAAY,WACZA,EAAA,YAAc,aACdA,EAAA,SAAW,WACXA,EAAA,YAAc,aACdA,EAAA,eAAiB,gBACjBA,EAAA,QAAU,UACVA,EAAA,OAAS,SACTA,EAAA,QAAU,UACVA,EAAA,IAAM,MACNA,EAAA,MAAQ,QAhBEA,OAAA,ICTZ,OAAS,WAAAC,EAAS,YAAAC,EAAU,YAAAC,MAAgB,OAC5C,OAAS,gBAAAP,MAAoB,KAE7B,eAAsBQ,EACpBC,EAAgB,CAAC,EACoB,CACrC,IAAMC,EAASC,EAAgBF,CAAK,EAMpC,MAAO,CACL,WALkBC,EACjB,IAAKE,GAAUA,EAAM,YAAY,EACjC,OAAO,CAACC,EAAGC,EAAG,IAAM,EAAE,QAAQD,CAAC,IAAMC,CAAC,EAGb,IAAKC,IACtB,CACL,KAAMA,GAAQ,SACd,kBACA,OAAQL,EAAO,OAAQE,GAAUA,EAAM,eAAiBG,CAAI,CAC9D,EACD,CACH,CACF,CAEA,SAASJ,EAAgBF,EAAwB,CAC/C,OAAKA,EAIEA,EACJ,IAAKO,GAAS,CACb,IAAMb,EAAOI,EAAS,QAAQ,IAAI,EAAGS,EAAK,QAAQ,EAClD,MAAO,CACL,KAAMV,EAASU,EAAK,SAAUX,EAAQW,EAAK,QAAQ,CAAC,EACpD,YAAab,EACb,aAAc,SACd,kBACA,SAAUA,EACV,mBACA,MAAOc,EAASD,EAAK,QAAQ,CAC/B,CACF,CAAC,EACA,OAAQJ,GAAUA,EAAM,IAAI,EAhBtB,CAAC,CAiBZ,CAEA,SAASK,EAASC,EAAkB,CAElC,IAAMC,EAASnB,EAAakB,CAAQ,EAEpC,OAAO,OAAO,KAAKC,CAAM,EAAE,SAAS,QAAQ,CAC9C,CCpDA,OAAOC,MAAuD,UAC9D,OAAOC,MAAU,eAMjB,eAAsBC,EACpBb,EAAgB,CAAC,EACjBc,EACAC,EAC8D,CAC9D,IAAMC,EAAgBhB,EAAM,OAC1B,CAACO,EAAMU,EAAOjB,IACZO,EAAK,SACL,CAACP,EAAM,KAAK,CAACkB,EAAGb,IAAMa,EAAE,UAAYX,EAAK,SAAWF,EAAIY,CAAK,CACjE,EAEME,EAAQ,MAAMC,EAASJ,EAAc,OAAQT,GAASA,EAAK,OAAO,CAAC,EAEnEc,EAAaC,EACjBH,EAAM,SACNA,EAAM,aACNL,CACF,EAEIS,EAAkBJ,GAAO,UAAU,IAAKK,GAAMA,EAAE,SAAS,CAAC,EAAE,KAAK,GAAG,EAExE,OAAIT,IACFQ,EACEA,EACA;AAAA,UACIJ,EAAM,aACL,IAAKM,GAAgBA,EAAY,SAAS,CAAC,EAC3C,KAAK,GAAG;AAAA,UAIV,CAAE,WAAAJ,EAAY,gBAAAE,CAAgB,CACvC,CAEA,SAASD,EACPI,EACAC,EACAb,EACY,CACZ,IAAMc,EAAmBF,EAAS,OAC/BG,GACCA,EAAQ,KAAK,SAAS,UAAU,GAAKA,EAAQ,KAAK,SAAS,aAAa,CAC5E,EAEA,OAAOD,EACJ,IAA0B,CAACC,EAASZ,IAAU,CAC7C,GAAIY,EAAQ,KAAK,SAAS,aAAa,EACrC,OAGF,IAAMC,EAAcF,EAAiBX,EAAQ,CAAC,EACxCc,EACJF,EAAQ,QAAQ,MAAM,OAASC,GAAa,QAAQ,MAAM,KACtDE,EAAc,gBAAgB,KAAKH,EAAQ,IAAI,EAG/CI,EAFmB,mBAAmB,KAAKJ,EAAQ,IAAI,IAER,CAAC,EAEtD,GACEI,GACA,CAAC,OAAO,OAAOtC,CAAc,EAAE,SAC5BsC,GAAa,EAChB,EAEA,MAAM,IAAI,MAAM,cAAcA,kBAA0B,EAG1D,IAAMC,EAAuB,CAC3B,KAAM,CACJ,OAAQL,EAAQ,QAAQ,OAAO,QAAU,EACzC,KAAMA,EAAQ,QAAQ,OAAO,MAAQ,CACvC,EACA,GACE,CAACE,GAA8BD,GAAa,KAAK,EAC7C,CACE,OAAQA,EAAY,KAAK,GAAG,QAAQ,KAAK,QAAU,EACnD,KAAMA,EAAY,KAAK,GAAG,QAAQ,KAAK,MAAQ,CACjD,EACA,CAACC,GAA8BD,EAC/B,CACE,OAAQA,EAAY,QAAQ,OAAO,QAAU,EAC7C,KAAMA,EAAY,QAAQ,OAAO,MAAQ,CAC3C,EACA,MACR,EAEMK,EAASN,EAAQ,QAAQ,MAAM,MAAQ,GAE7C,MAAO,CACL,KAAMG,IAAc,CAAC,GAAK,GAC1B,UAAAC,EACA,MAAAC,EACA,OAAAC,EACA,OAAQC,EACND,EACAD,EACAP,EACAD,EACAZ,EACAmB,CACF,CACF,CACF,CAAC,EACA,OAAiBI,CAAU,CAChC,CAEA,SAASD,EACPD,EACAD,EACAP,EACAD,EACAZ,EACAmB,EACS,CAQT,OAPgCN,EAAa,OAC1CF,GACCA,EAAY,QAAQ,MAAM,OAASU,IAClCV,EAAY,QAAQ,OAAO,MAAQ,IAAMS,EAAM,KAAK,OACpD,CAACA,EAAM,KAAOT,EAAY,QAAQ,OAAO,MAAQ,KAAOS,EAAM,GAAG,KACtE,EAGG,IAAKT,GAAgB,CACpB,IAAMa,EAAcZ,EAAS,KAC1BG,GACCA,EAAQ,QAAQ,MAAM,OAASJ,EAAY,QAAQ,MAAM,MACzDI,EAAQ,QAAQ,OAAO,OAASJ,EAAY,QAAQ,KAAK,IAC7D,EAEMc,EAAQC,EAAoBf,EAAY,MAAOE,CAAY,EAC7Dc,EAEJ,GAAIH,EAAa,CACf,IAAMI,EAAwB,mBAAmB,KAAKJ,EAAY,IAAI,EAElEI,IACFD,EAAiBC,EAAsB,CAAC,EACxCJ,EAAY,KAAOA,EAAY,KAAK,QAClCI,EAAsB,CAAC,GAAK,GAC5B,EACF,GAIJ,MAAO,CACL,YAAaJ,GAAa,KAC1B,QAASC,IAAUd,EAAY,MAC/B,KAAMA,EAAY,KAClB,UAAWgB,GAAkBR,EAC7B,SAAUR,EAAY,MACtB,WAAAX,EACA,MAAAyB,EACA,WAAYd,EAAY,QAAQ,MAAM,MAAQ,EAChD,CACF,CAAC,EACA,MAAM,EACN,QAAQ,EACR,OACC,CAACtB,EAAOc,EAAOhB,IACbgB,IAAUhB,EAAO,UAAW0C,GAAMA,EAAE,OAASxC,EAAM,IAAI,CAC3D,EACC,QAAQ,CACb,CAEA,SAASqC,EACPI,EACAjB,EACQ,CACRiB,EAAWA,EAAS,QAAQ,YAAa,EAAE,EAAE,QAAQ,WAAY,EAAE,EAEnE,IAAMC,EAAQ,uDACVC,EACAC,EAAiBH,EACrB,MAAQE,EAAQD,EAAM,KAAKD,CAAQ,KAAO,MAAM,CAC9C,IAAMI,EAAgBF,EAAM,CAAC,EACvBG,EAAeD,EAAc,QAAQ,oBAAqB,EAAE,EAC5DE,EACJvB,EAAa,KACVF,GACCA,EAAY,OAASwB,GACrBxB,EAAY,OAAS,IAAIwB,KACzBxB,EAAY,OAAS,IAAIwB,GAC7B,GAAG,OAAS,GAEdF,EAAiBA,EAAe,QAAQC,EAAeE,CAAW,EAGpE,OAAOH,CACT,CAEA,eAAe3B,EAASpB,EAIrB,CACD,IAAM0B,EAAsB,CAAC,EACvBC,EAA8B,CAAC,EAC/BwB,EAAsB,CAAC,EAEvBC,EAAiB,CACrB,cAAe,gCACf,KAAKC,EAAM,CACTA,EAAK,YAAaC,GAAW,CAC3B,GAAIA,EAAO,OAAS,YAAa,CAC/BH,EAAU,KAAKG,CAAM,EACrB,OAGF,IAAMC,EAAiBD,EAEnBC,EAAe,KAAK,SAAS,GAAG,GAClC5B,EAAa,KAAK,CAChB,GAAG4B,EACH,KAAM,IAAIA,EAAe,KAAK,OAC5B,EACAA,EAAe,KAAK,OAAS,CAC/B,IACA,MAAOA,EAAe,MACxB,CAAQ,CAEZ,CAAC,EAEDF,EAAK,aAAcxB,GAAY,CAC7BH,EAAS,KAAKG,CAAO,CACvB,CAAC,EAEDwB,EAAK,UAAW5B,GAAgB,EAE5BA,EAAY,KAAK,WAAW,IAAI,GAChCA,EAAY,KAAK,WAAW,GAAG,IAE/BE,EAAa,KAAKF,CAAW,CAEjC,CAAC,CACH,CACF,EAEA,aAAM,QAAQ,IACZzB,EAAM,IAAKO,GAAS,CAClB,IAAMiD,EACJjD,EAAK,SAAS,SAAS,OAAO,GAAKA,EAAK,SAAS,SAAS,OAAO,EAC7DK,EACA,OAEN,OAAOD,EAAQ,CAACyC,CAAM,CAAC,EAAE,QAAQ7C,EAAK,QAAS,CAC7C,KAAMA,EAAK,SACX,OAAAiD,CACF,CAAC,CACH,CAAC,CACH,EAEO,CAAE,SAAA9B,EAAU,aAAAC,EAAc,UAAAwB,CAAU,CAC7C,CAEA,SAASd,EAAWoB,EAAiC,CACnD,MAAO,CAAC,CAACA,GAAUA,EAAO,eAAe,WAAW,CACtD,CCvQA,OAAS,SAAAC,MAAa,QACtB,OAAS,YAAA7D,EAAU,WAAAD,MAAe,OAMlC,eAAsB+D,EACpB3D,EAAgB,CAAC,EACoB,CACrC,IAAMC,EAASC,EAAgBF,CAAK,EAMpC,MAAO,CACL,WALkBC,EACjB,IAAKE,GAAUA,EAAM,YAAY,EACjC,OAAO,CAACC,EAAGC,EAAG,IAAM,EAAE,QAAQD,CAAC,IAAMC,CAAC,EAGb,IAAKC,IACtB,CACL,KAAMA,GAAQ,YACd,gBACA,OAAQL,EAAO,OAAQE,GAAUA,EAAM,eAAiBG,CAAI,CAC9D,EACD,CACH,CACF,CAEA,SAASJ,EAAgBF,EAAwB,CAC/C,GAAI,CAACA,EACH,MAAO,CAAC,EAGV,GAAM,CAAE,SAAA4D,CAAS,EAAI,IAAIF,EAAM,EAAE,OAEjC,OAAO1D,EACJ,IAAKO,GAAS,CACb,IAAMsD,EAAMD,EAAS,cAAc,KAAK,EACxCC,EAAI,UAAYtD,EAAK,QAErB,IAAMuD,EAAO,MAAM,KAAKD,EAAI,iBAAiB,KAAK,CAAC,EAC7CvD,EAAOT,EAASU,EAAK,SAAUX,EAAQW,EAAK,QAAQ,CAAC,EAE3D,OAAOuD,EACJ,IAAI,CAACC,EAAK9C,EAAO+C,KAAW,CAC3B,KACED,GAAK,aAAa,iBAAiB,GACnCA,GAAK,aAAa,IAAI,IACrBC,EAAM,OAAS,EAAI,GAAG1D,KAAQW,EAAQ,IAAMX,GAC/C,YAAayD,GAAK,aAAa,wBAAwB,GAAK,GAC5D,aAAcA,GAAK,aAAa,qBAAqB,GAAK,YAC1D,gBACA,SAAUA,EAAI,UACd,iBACA,MAAOA,EAAI,SACb,EAAE,EACD,OAAQ5D,GAAUA,EAAM,IAAI,CACjC,CAAC,EACA,KAAK,CACV,CJjDA,SAAS8D,EAAkBC,EAAcC,EAAoC,CAC3E,IAAMC,EAAU1E,EACb,KACCwE,EACAC,GACE,QAAQ,IAAI,mBACZ,uCACJ,EACC,QAAQ,MAAO,GAAG,EAErB,OAAO1E,EAAK,KAAK2E,EAAS,CACxB,OAAQ,CAAC,qBAAsB,yBAA0B,cAAc,CACzE,CAAC,CACH,CAEA,SAASC,EAAsBC,EAAkBtE,EAAiB,CAChEsE,EAAY,iBAAiB,OAAOtE,CAAK,CAC3C,CAEA,eAAeuE,EAA6BvE,EAAkC,CAC5E,IAAMwE,EAAaxE,EAChB,IAAKN,IAAU,CACd,SAAUA,EACV,QAASH,EAAaG,EAAM,OAAO,CACrC,EAAE,EACD,OACEa,GACCA,EAAK,QAAQ,SAAS,SAAS,GAC/BA,EAAK,SAAS,SAAS,MAAM,GAC7BkE,EAAiBlE,EAAK,QAAQ,CAClC,EAEImE,EAAY,MAAM7D,EACtB2D,EAAW,OAAQjE,GAASA,EAAK,SAAS,SAAS,MAAM,CAAC,QAE1D,EACF,EAEMoE,EAAa,MAAM9D,EACvB2D,EAAW,OAAQjE,GAASA,EAAK,SAAS,SAAS,OAAO,CAAC,SAE3D,EACF,EAEMqE,EAAa,MAAM/D,EACvB2D,EAAW,OAAQjE,GAASA,EAAK,SAAS,SAAS,OAAO,CAAC,SAE3D,EACF,EAEMsE,EAAY,MAAMlB,EACtBa,EAAW,OAAQjE,GAASA,EAAK,SAAS,SAAS,MAAM,CAAC,CAC5D,EAEMuE,EAAc,MAAM/E,EACxByE,EAAW,OAAQjE,GAASkE,EAAiBlE,EAAK,QAAQ,CAAC,CAC7D,EAEA,OAAO,KAAK,UAAU,CACpB,UAAAmE,EACA,WAAAC,EACA,WAAAC,EACA,UAAAC,EACA,YAAAC,CACF,CAAC,CACH,CAEO,IAAMC,EAAN,KAAiC,CACtC,YAAoBZ,EAA0B,CAA1B,qBAAAA,CAA2B,CAExC,MAAMa,EAAe,CAC1BA,EAAS,MAAM,WAAW,IAAI,6BAA8B,IAAM,CAChE,IAAMhF,EAAQiE,EAAkBe,EAAS,QAAS,KAAK,eAAe,EAEtEA,EAAS,MAAM,KAAK,IAClB,6BACCV,GAAqB,CACpBD,EAAsBC,EAAatE,CAAK,CAC1C,CACF,EAEAgF,EAAS,MAAM,gBAAgB,IAC7B,6BACCV,GAAqB,CACpBA,EAAY,MAAM,cAAc,SAC9B,CACE,KAAM,oBACN,MACEU,EAAS,QAAQ,YACd,oCACP,EACA,MAAOC,EAAwBC,IAAkB,CAC/C,IAAMC,EAAe,MAAMZ,EAA6BvE,CAAK,EAE7DiF,EAAkB,2BAA2B,EAAI,CAC/C,OAAQ,IACCE,EAET,KAAM,IACGA,EAAa,MAExB,EAEAD,EAAS,CACX,CACF,CACF,CACF,CACF,CAAC,CACH,CACF,EAEO,SAASE,EAA+BC,EAAc,CAC3D,IAAIC,EACAC,EACAvF,EAEJ,MAAO,CACL,KAAM,qCACN,eAAewF,EAAqB,CAClCF,EAAYE,EAAe,UAC3BD,EAAUC,EAAe,IAC3B,EACA,UAAW,gBAAkB,CAC3B,GAAI,CAACF,EACH,OAGFtF,EAAQiE,EAAkB,KAAMoB,GAAS,eAAe,EAAE,IACvD9E,GAAS,KAAKA,GACjB,EAEA,IAAM4E,EAAe,MAAMZ,EAA6BvE,CAAK,EAExDX,EAAWiG,CAAS,GACvBhG,EAAUgG,CAAS,EAGrB9F,EACEE,EAAK,KAAK4F,EAAW,2BAA2B,EAChDH,CACF,CACF,CACF,CACF,CAEA,SAASV,EAAiBgB,EAAkB,CAC1C,OACEA,EAAS,SAAS,OAAO,GACzBA,EAAS,SAAS,MAAM,GACxBA,EAAS,SAAS,MAAM,CAE5B,CKvJO,SAASC,GAAeC,EAAe,CAAC,EAAG,CAChD,MAAO,CAAC,GAAGA,EAAOC,EAAQ,QAAQ,WAAW,CAAC,CAChD,CAEO,IAAMC,GAAY,MACvBC,EACAT,KAEAS,EAAW,QAAUA,EAAW,SAAW,CAAC,EAC5CA,EAAW,QAAQ,KAAKV,EAA+BC,CAAO,CAAC,EAExDS,GAGT,eAAsBC,GACpBC,EACA,CAAE,gBAAA7B,EAAiB,QAAA8B,CAAQ,EAC3B,CAGA,GAFgB,MAAMA,EAAQ,MAAM,gBAAgB,GAErC,EACbD,EAAO,QAAQ,KAAK,IAAIjB,EAA2BZ,CAAe,CAAC,MAEnE,OAAM,MACJ,iEACF,EAGF,OAAO6B,CACT","sourcesContent":["import { existsSync, mkdirSync, readFileSync, writeFileSync } from \"fs\";\nimport glob from \"glob\";\nimport path from \"path\";\n\nimport { parsePngFiles } from \"./parsers/image.parser\";\nimport { parseCssFiles } from \"./parsers/postcss.parser\";\nimport { parseSvgFiles } from \"./parsers/svg-icon.parser\";\nimport { TokenSourceType } from \"./types/token.types\";\n\nfunction getTokenFilePaths(context: any, designTokenGlob?: string): string[] {\n  const pattern = path\n    .join(\n      context,\n      designTokenGlob ||\n        process.env.DESIGN_TOKEN_GLOB ||\n        \"**/*.{css,scss,less,svg,png,jpeg,gif}\"\n    )\n    .replace(/\\\\/g, \"/\");\n\n  return glob.sync(pattern, {\n    ignore: [\"**/node_modules/**\", \"**/storybook-static/**\", \"**/*.chunk.*\"],\n  });\n}\n\nfunction addFilesToWebpackDeps(compilation: any, files: string[]) {\n  compilation.fileDependencies.addAll(files);\n}\n\nasync function generateTokenFilesJsonString(files: string[]): Promise<string> {\n  const tokenFiles = files\n    .map((path) => ({\n      filename: path,\n      content: readFileSync(path, \"utf-8\"),\n    }))\n    .filter(\n      (file) =>\n        file.content.includes(\"@tokens\") ||\n        file.filename.endsWith(\".svg\") ||\n        isImageExtension(file.filename)\n    );\n\n  const cssTokens = await parseCssFiles(\n    tokenFiles.filter((file) => file.filename.endsWith(\".css\")),\n    TokenSourceType.CSS,\n    true\n  );\n\n  const scssTokens = await parseCssFiles(\n    tokenFiles.filter((file) => file.filename.endsWith(\".scss\")),\n    TokenSourceType.SCSS,\n    true\n  );\n\n  const lessTokens = await parseCssFiles(\n    tokenFiles.filter((file) => file.filename.endsWith(\".less\")),\n    TokenSourceType.LESS,\n    true\n  );\n\n  const svgTokens = await parseSvgFiles(\n    tokenFiles.filter((file) => file.filename.endsWith(\".svg\"))\n  );\n\n  const imageTokens = await parsePngFiles(\n    tokenFiles.filter((file) => isImageExtension(file.filename))\n  );\n\n  return JSON.stringify({\n    cssTokens,\n    scssTokens,\n    lessTokens,\n    svgTokens,\n    imageTokens,\n  });\n}\n\nexport class StorybookDesignTokenPlugin {\n  constructor(private designTokenGlob?: string) {}\n\n  public apply(compiler: any) {\n    compiler.hooks.initialize.tap(\"StorybookDesignTokenPlugin\", () => {\n      const files = getTokenFilePaths(compiler.context, this.designTokenGlob);\n\n      compiler.hooks.emit.tap(\n        \"StorybookDesignTokenPlugin\",\n        (compilation: any) => {\n          addFilesToWebpackDeps(compilation, files);\n        }\n      );\n\n      compiler.hooks.thisCompilation.tap(\n        \"StorybookDesignTokenPlugin\",\n        (compilation: any) => {\n          compilation.hooks.processAssets.tapAsync(\n            {\n              name: \"HtmlWebpackPlugin\",\n              stage:\n                compiler.webpack.Compilation\n                  .PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,\n            },\n            async (compilationAssets: any, callback: any) => {\n              const sourceString = await generateTokenFilesJsonString(files);\n\n              compilationAssets[\"design-tokens.source.json\"] = {\n                source: () => {\n                  return sourceString;\n                },\n                size: () => {\n                  return sourceString.length;\n                },\n              };\n\n              callback();\n            }\n          );\n        }\n      );\n    });\n  }\n}\n\nexport function viteStorybookDesignTokenPlugin(options: any) {\n  let publicDir: string;\n  let rootDir: string;\n  let files: string[];\n\n  return {\n    name: \"vite-storybook-design-token-plugin\",\n    configResolved(resolvedConfig: any) {\n      publicDir = resolvedConfig.publicDir;\n      rootDir = resolvedConfig.root;\n    },\n    transform: async function () {\n      if (!publicDir) {\n        return;\n      }\n\n      files = getTokenFilePaths(\"./\", options?.designTokenGlob).map(\n        (file) => `./${file}`\n      );\n\n      const sourceString = await generateTokenFilesJsonString(files);\n\n      if (!existsSync(publicDir)) {\n        mkdirSync(publicDir);\n      }\n\n      writeFileSync(\n        path.join(publicDir, \"design-tokens.source.json\"),\n        sourceString\n      );\n    },\n  } as any;\n}\n\nfunction isImageExtension(filename: string) {\n  return (\n    filename.endsWith(\".jpeg\") ||\n    filename.endsWith(\".png\") ||\n    filename.endsWith(\".gif\")\n  );\n}\n","export interface Token {\n  description?: string;\n  isAlias?: boolean;\n  name: string;\n  categoryName?: string;\n  presenter?: TokenPresenter;\n  rawValue: string;\n  sourceType: TokenSourceType;\n  value: string;\n  sourcePath: string;\n}\n\nexport enum TokenPresenter {\n  ANIMATION = \"Animation\",\n  BORDER = \"Border\",\n  BORDER_RADIUS = \"BorderRadius\",\n  COLOR = \"Color\",\n  EASING = \"Easing\",\n  FONT_FAMILY = \"FontFamily\",\n  FONT_SIZE = \"FontSize\",\n  FONT_WEIGHT = \"FontWeight\",\n  GRADIENT = \"Gradient\",\n  LINE_HEIGHT = \"LineHeight\",\n  LETTER_SPACING = \"LetterSpacing\",\n  OPACITY = \"Opacity\",\n  SHADOW = \"Shadow\",\n  SPACING = \"Spacing\",\n  SVG = \"Svg\",\n  IMAGE = \"Image\",\n}\n\nexport enum TokenSourceType {\n  CSS = \"CSS\",\n  LESS = \"Less\",\n  SCSS = \"SCSS\",\n  SVG = \"SVG\",\n  THEO = \"THEO\",\n  IMAGE = \"IMAGE\",\n}\n\nexport interface PresenterProps {\n  token: Token;\n}\n","import { Category } from \"../types/category.types\";\nimport { File } from \"../types/config.types\";\nimport { Token, TokenPresenter, TokenSourceType } from \"../types/token.types\";\nimport { extname, basename, relative } from \"path\";\nimport { readFileSync } from \"fs\";\n\nexport async function parsePngFiles(\n  files: File[] = []\n): Promise<{ categories: Category[] }> {\n  const tokens = determineTokens(files);\n\n  let categoryNames = tokens\n    .map((token) => token.categoryName)\n    .filter((v, i, a) => a.indexOf(v) === i);\n\n  return {\n    categories: categoryNames.map((name) => {\n      return {\n        name: name || \"Images\",\n        presenter: TokenPresenter.IMAGE,\n        tokens: tokens.filter((token) => token.categoryName === name),\n      };\n    }),\n  };\n}\n\nfunction determineTokens(files: File[]): Token[] {\n  if (!files) {\n    return [];\n  }\n\n  return files\n    .map((file) => {\n      const path = relative(process.cwd(), file.filename);\n      return {\n        name: basename(file.filename, extname(file.filename)),\n        description: path,\n        categoryName: \"Images\",\n        presenter: TokenPresenter.IMAGE,\n        rawValue: path,\n        sourceType: TokenSourceType.IMAGE,\n        value: toBase64(file.filename),\n      };\n    })\n    .filter((token) => token.name);\n}\n\nfunction toBase64(filePath: string) {\n  // read binary data\n  const bitmap = readFileSync(filePath);\n  // convert binary data to base64 encoded string\n  return Buffer.from(bitmap).toString(\"base64\");\n}\n","import postcss, { AtRule, Comment, Declaration, Plugin } from \"postcss\";\nimport scss from \"postcss-scss\";\n\nimport { Category, CategoryRange } from \"../types/category.types\";\nimport { File } from \"../types/config.types\";\nimport { Token, TokenPresenter, TokenSourceType } from \"../types/token.types\";\n\nexport async function parseCssFiles(\n  files: File[] = [],\n  sourceType: TokenSourceType,\n  injectVariables?: boolean\n): Promise<{ categories: Category[]; injectionStyles: string }> {\n  const relevantFiles = files.filter(\n    (file, index, files) =>\n      file.content &&\n      !files.some((f, i) => f.content === file.content && i < index)\n  );\n\n  const nodes = await getNodes(relevantFiles.filter((file) => file.content));\n\n  const categories = determineCategories(\n    nodes.comments,\n    nodes.declarations,\n    sourceType\n  );\n\n  let injectionStyles = nodes?.keyframes.map((k) => k.toString()).join(\" \");\n\n  if (injectVariables) {\n    injectionStyles =\n      injectionStyles +\n      `:root {\n        ${nodes.declarations\n          .map((declaration) => declaration.toString())\n          .join(\";\")}\n      }`;\n  }\n\n  return { categories, injectionStyles };\n}\n\nfunction determineCategories(\n  comments: Comment[],\n  declarations: Declaration[],\n  sourceType: TokenSourceType\n): Category[] {\n  const categoryComments = comments.filter(\n    (comment) =>\n      comment.text.includes(\"@tokens \") || comment.text.includes(\"@tokens-end\")\n  );\n\n  return categoryComments\n    .map<Category | undefined>((comment, index) => {\n      if (comment.text.includes(\"@tokens-end\")) {\n        return undefined;\n      }\n\n      const nextComment = categoryComments[index + 1];\n      const nextCommentIsInAnotherFile =\n        comment.source?.input.file !== nextComment?.source?.input.file;\n      const nameResults = /@tokens (.+)/g.exec(comment.text);\n      const presenterResults = /@presenter (.+)/g.exec(comment.text);\n\n      const presenter: TokenPresenter = presenterResults?.[1] as TokenPresenter;\n\n      if (\n        presenter &&\n        !Object.values(TokenPresenter).includes(\n          (presenter || \"\") as TokenPresenter\n        )\n      ) {\n        throw new Error(`Presenter \"${presenter}\" is not valid.`);\n      }\n\n      const range: CategoryRange = {\n        from: {\n          column: comment.source?.start?.column || 0,\n          line: comment.source?.start?.line || 0,\n        },\n        to:\n          !nextCommentIsInAnotherFile && nextComment?.prev()\n            ? {\n                column: nextComment.prev()?.source?.end?.column || 0,\n                line: nextComment.prev()?.source?.end?.line || 0,\n              }\n            : !nextCommentIsInAnotherFile && nextComment\n            ? {\n                column: nextComment.source?.start?.column || 0,\n                line: nextComment.source?.start?.line || 0,\n              }\n            : undefined,\n      };\n\n      const source = comment.source?.input.from || \"\";\n\n      return {\n        name: nameResults?.[1] || \"\",\n        presenter,\n        range,\n        source,\n        tokens: determineTokensForCategory(\n          source,\n          range,\n          declarations,\n          comments,\n          sourceType,\n          presenter\n        ),\n      };\n    })\n    .filter<Category>(isCategory);\n}\n\nfunction determineTokensForCategory(\n  source: string,\n  range: CategoryRange,\n  declarations: Declaration[],\n  comments: Comment[],\n  sourceType: TokenSourceType,\n  presenter: TokenPresenter\n): Token[] {\n  const declarationsWithinRange = declarations.filter(\n    (declaration) =>\n      declaration.source?.input.from === source &&\n      (declaration.source?.start?.line || -1) > range.from.line &&\n      (!range.to || (declaration.source?.start?.line || -1) <= range.to.line)\n  );\n\n  return declarationsWithinRange\n    .map((declaration) => {\n      const description = comments.find(\n        (comment) =>\n          comment.source?.input.file === declaration.source?.input.file &&\n          comment.source?.start?.line === declaration.source?.end?.line\n      );\n\n      const value = determineTokenValue(declaration.value, declarations);\n      let presenterToken: TokenPresenter | undefined;\n\n      if (description) {\n        const presenterResultsToken = /@presenter (.+)/g.exec(description.text);\n\n        if (presenterResultsToken) {\n          presenterToken = presenterResultsToken[1] as TokenPresenter;\n          description.text = description.text.replace(\n            presenterResultsToken[0] || \"\",\n            \"\"\n          );\n        }\n      }\n\n      return {\n        description: description?.text,\n        isAlias: value !== declaration.value,\n        name: declaration.prop,\n        presenter: presenterToken || presenter,\n        rawValue: declaration.value,\n        sourceType,\n        value,\n        sourcePath: declaration.source?.input.from || \"\",\n      };\n    })\n    .slice()\n    .reverse()\n    .filter(\n      (token, index, tokens) =>\n        index === tokens.findIndex((t) => t.name === token.name)\n    )\n    .reverse();\n}\n\nfunction determineTokenValue(\n  rawValue: string,\n  declarations: Declaration[]\n): string {\n  rawValue = rawValue.replace(/!default/g, \"\").replace(/!global/g, \"\");\n\n  const regex = /\\bvar\\(([^)]+)\\)|(\\$[a-zA-Z0-9-_]+|@[a-zA-Z0-9-_]+)/g;\n  let match;\n  let replacedString = rawValue;\n  while ((match = regex.exec(rawValue)) !== null) {\n    const variableMatch = match[0];\n    const variableName = variableMatch.replace(/\\(|\\)|var\\(|@|\\$/g, \"\");\n    const replacement =\n      declarations.find(\n        (declaration) =>\n          declaration.prop === variableName ||\n          declaration.prop === `$${variableName}` ||\n          declaration.prop === `@${variableName}`\n      )?.value || \"\";\n\n    replacedString = replacedString.replace(variableMatch, replacement);\n  }\n\n  return replacedString;\n}\n\nasync function getNodes(files: File[]): Promise<{\n  comments: Comment[];\n  declarations: Declaration[];\n  keyframes: AtRule[];\n}> {\n  const comments: Comment[] = [];\n  const declarations: Declaration[] = [];\n  const keyframes: AtRule[] = [];\n\n  const plugin: Plugin = {\n    postcssPlugin: \"storybook-design-token-parser\",\n    Once(root) {\n      root.walkAtRules((atRule) => {\n        if (atRule.name === \"keyframes\") {\n          keyframes.push(atRule);\n          return;\n        }\n\n        const variableAtRule = atRule;\n\n        if (variableAtRule.name.endsWith(\":\")) {\n          declarations.push({\n            ...variableAtRule,\n            prop: `@${variableAtRule.name.substr(\n              0,\n              variableAtRule.name.length - 1\n            )}`,\n            value: variableAtRule.params,\n          } as any);\n        }\n      });\n\n      root.walkComments((comment) => {\n        comments.push(comment);\n      });\n\n      root.walkDecls((declaration) => {\n        if (\n          declaration.prop.startsWith(\"--\") ||\n          declaration.prop.startsWith(\"$\")\n        ) {\n          declarations.push(declaration);\n        }\n      });\n    },\n  };\n\n  await Promise.all(\n    files.map((file) => {\n      const syntax: any =\n        file.filename.endsWith(\".scss\") || file.filename.endsWith(\".less\")\n          ? scss\n          : undefined;\n\n      return postcss([plugin]).process(file.content, {\n        from: file.filename,\n        syntax,\n      });\n    })\n  );\n\n  return { comments, declarations, keyframes };\n}\n\nfunction isCategory(object: any): object is Category {\n  return !!object && object.hasOwnProperty(\"presenter\");\n}\n","import { JSDOM } from \"jsdom\";\nimport { basename, extname } from \"path\";\n\nimport { Category } from \"../types/category.types\";\nimport { File } from \"../types/config.types\";\nimport { Token, TokenPresenter, TokenSourceType } from \"../types/token.types\";\n\nexport async function parseSvgFiles(\n  files: File[] = []\n): Promise<{ categories: Category[] }> {\n  const tokens = determineTokens(files);\n\n  let categoryNames = tokens\n    .map((token) => token.categoryName)\n    .filter((v, i, a) => a.indexOf(v) === i);\n\n  return {\n    categories: categoryNames.map((name) => {\n      return {\n        name: name || \"SVG Icons\",\n        presenter: TokenPresenter.SVG,\n        tokens: tokens.filter((token) => token.categoryName === name),\n      };\n    }),\n  };\n}\n\nfunction determineTokens(files: File[]): Token[] {\n  if (!files) {\n    return [];\n  }\n\n  const { document } = new JSDOM().window;\n\n  return files\n    .map((file) => {\n      const div = document.createElement(\"div\");\n      div.innerHTML = file.content;\n\n      const svgs = Array.from(div.querySelectorAll(\"svg\"));\n      const name = basename(file.filename, extname(file.filename));\n\n      return svgs\n        .map((svg, index, array) => ({\n          name:\n            svg?.getAttribute(\"data-token-name\") ||\n            svg?.getAttribute(\"id\") ||\n            (array.length > 1 ? `${name}-${index + 1}` : name),\n          description: svg?.getAttribute(\"data-token-description\") || \"\",\n          categoryName: svg?.getAttribute(\"data-token-category\") || \"SVG Icons\",\n          presenter: TokenPresenter.SVG,\n          rawValue: svg.outerHTML,\n          sourceType: TokenSourceType.SVG,\n          value: svg.outerHTML,\n        }))\n        .filter((token) => token.name);\n    })\n    .flat();\n}\n","import {\n  StorybookDesignTokenPlugin,\n  viteStorybookDesignTokenPlugin,\n} from \"./plugin\";\n\ntype AddonOptions = {\n  designTokenGlob?: string;\n  presets: any;\n};\n\nexport function managerEntries(entry: any[] = []) {\n  return [...entry, require.resolve(\"./manager\")];\n}\n\nexport const viteFinal = async (\n  viteConfig: Record<string, any>,\n  options: any\n) => {\n  viteConfig.plugins = viteConfig.plugins || [];\n  viteConfig.plugins.push(viteStorybookDesignTokenPlugin(options));\n\n  return viteConfig;\n};\n\nexport async function webpackFinal(\n  config: any,\n  { designTokenGlob, presets }: AddonOptions\n) {\n  const version = await presets.apply(\"webpackVersion\");\n\n  if (version >= 5) {\n    config.plugins.push(new StorybookDesignTokenPlugin(designTokenGlob));\n  } else {\n    throw Error(\n      \"Webpack 4 is not supported by the storybook-design-token addon.\"\n    );\n  }\n\n  return config;\n}\n"]}